%% tpbvp_bc.m
%
% Description:
%   Computes residuals for the boundary conditions for an optimal swingup
%   two-point boundary value problem (TPBVP) with constraints on the
%   initial state z0 and final state zT. The TPBVP state vector at time t
%   is
%       z(t) = [x(t); lambda(t)],
%   where the robot state vector at time t is
%       x(t) = [x_cart(t);theta_pend(t);dx_cart(t);dtheta_cart(t)]
%   and where the costate vector at time t is
%       lambda(t) = [lambda1(t); lambda2(t); lambda3(t); lambda4(t)].
%
%   This TPBVP results from applying Pontryagin's Maximum Principle (PMP)
%   to the optimal swingup problem. PMP provides necessary conditions of
%   optimality and results in a TPBVP with an 8-dimensional state, formed
%   by concatenating the 4-dimensional robot state "x" with the
%   4-dimensional costate "lambda".
%
%   In this problem, the initial robot state x(0) and final robot state
%   x(T) are both fully constrained, and consequently the initial costate
%   lambda(0) and final costate lambda(T) are both fully unconstrained,
%   resulting in 8 equations (the TPBVP dynamics) and 8 constraints (x(0)
%   and x(T)), so the problem appears well-posed.
%
%   tpbvp_bc.m supports both fixed-time and free-time versions of the
%   optimal swingup TPBVP. In the free-time case, there is an additional
%   "dummy" state "rho" that corresponds to the optimal time scaling:
%       z = [x;lambda;rho],
%       d(rho)/d(tau) = 0,
%       rho(1) = T
%   where 0 <= tau <= 1 is dimensionless time and T is the dimensional time
%   it takes to complete the swingup trajectory.
%
%   MATLAB's BVP solver will automatically solve for T. With the addition
%   of another state variable, there must also be an additional constraint
%   (to maintain well-posedness). This additional constraint is that the
%   control Hamiltonian H must equal 0 at time t=T (whatever T turns out to
%   be). This transversality constraint arises when PMP is applied to
%   free-time problems.
%
% Inputs:
%   z0, zT: (8x1 or 9x1 column vectors). If z0 and zT are 8x1 (fixed-time 
%       TPBVP), then:
%       z = [x;lambda] where the robot state is
%       x = [q; dq]
%         = [x_cart; theta_pend; dx_cart; dtheta_pend] and where the
%       costate is
%           lambda = [lambda1; lambda2; lambda3; lambda4].
%       If z0 and zT are 9x1 (free-time TPBVP), then:
%       z = [x;lambda;rho] where the robot state is
%       x = [q; dq]
%         = [x_cart; theta_pend; dx_cart; dtheta_pend]; where the
%       costate is
%           lambda = [lambda1; lambda2; lambda3; lambda4]; and where "rho"
%           is a dummy scalar variable that is required to solve a
%           free-time TPBVP with MATLAB's bvp4c or bvp5c solver.
%   params: a struct with many elements, generated by calling init_params.m
%
% Outputs:
%   res: an 8x1 or 9x1 column vector of the residual of the boundary
%       conditions. 8x1 for fixed-time swingup, 9x1 for free-time swingup.


function res = tpbvp_bc(z0,zT,params)

if ((numel(z0)==8) && (numel(zT)==8)) % fixed-time problem
    res = zeros(8,1);
    
    % constraints on initial robot state x(0):
    res(1) = z0(1) - params.control.swingup.TPBVP.x0(1);
    res(2) = z0(2) - params.control.swingup.TPBVP.x0(2);
    res(3) = z0(3) - params.control.swingup.TPBVP.x0(3);
    res(4) = z0(4) - params.control.swingup.TPBVP.x0(4);
    
    % constraints on final robot state x(T):
    res(5) = zT(1) - params.control.swingup.TPBVP.xT(1);
    res(6) = zT(2) - params.control.swingup.TPBVP.xT(2);
    res(7) = zT(3) - params.control.swingup.TPBVP.xT(3);
    res(8) = zT(4) - params.control.swingup.TPBVP.xT(4);
    
elseif ((numel(z0)==9) && (numel(zT)==9)) % free-time problem
    res = zeros(9,1);
    
    % constraints on initial robot state x(0):
    res(1) = z0(1) - params.control.swingup.TPBVP.x0(1);
    res(2) = z0(2) - params.control.swingup.TPBVP.x0(2);
    res(3) = z0(3) - params.control.swingup.TPBVP.x0(3);
    res(4) = z0(4) - params.control.swingup.TPBVP.x0(4);
    
    % constraints on final robot state x(T):
    res(5) = zT(1) - params.control.swingup.TPBVP.xT(1);
    res(6) = zT(2) - params.control.swingup.TPBVP.xT(2);
    res(7) = zT(3) - params.control.swingup.TPBVP.xT(3);
    res(8) = zT(4) - params.control.swingup.TPBVP.xT(4);
    
    % PMP's free-time transversality condition is H(T) = 0:
    u_PMP = control_PMP(x,lambda,params); % compute u using PMP
    res(9) = control_Hamiltonian(zT(1:4),zT(5:8),u_PMP,params);
    
else % z has invalid dimensions
    errormsg = sprintf(['TPBVP initial state z(0) has dimensions %d-by-%d',...
        ' and TPBVP final state z(T) has dimensions %d-by-%d\n'],...
        size(z0),size(zT));
    error(errormsg);
end
end