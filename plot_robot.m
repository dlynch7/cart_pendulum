%% plot_robot.m
%
% Description:
%   Plots the robot in its current configuration.
%   
% Inputs:
%   q: robot configuration, q = [x_cart; theta_pend];
%   params: a struct with many elements, generated by calling init_params.m
%
% Outputs:
%   none
%
% Notes:
%   1) This code is written verbosely in the hope that it is clear how to
%   extend it to visualizing other more complex robots.
function plot_robot(q,params)

%% Compute the 4 corners of the cart, clockwise from top left corner
% First compute the cart's home position (q(1) = 0):
cart.home.upp_left.x    = -0.5*params.model.geom.cart.w;
cart.home.upp_left.y    = 0.5*params.model.geom.cart.h;

cart.home.upp_right.x   = 0.5*params.model.geom.cart.w;
cart.home.upp_right.y   = 0.5*params.model.geom.cart.h;

cart.home.low_right.x   = 0.5*params.model.geom.cart.w;
cart.home.low_right.y   = -0.5*params.model.geom.cart.h;

cart.home.low_left.x    = -0.5*params.model.geom.cart.w;
cart.home.low_left.y    = -0.5*params.model.geom.cart.h;

cart.home.corners = horzcat([cart.home.upp_left.x; cart.home.upp_left.y],...
                            [cart.home.upp_right.x; cart.home.upp_right.y],...
                            [cart.home.low_right.x; cart.home.low_right.y],...
                            [cart.home.low_left.x;  cart.home.low_left.y]);

% The cart can translate horizontally by q(1) but cannot translate
% vertically or rotate, so we don't bother computing a homogeneous
% transformation matrix in SE(2) for the cart. Instead we do the math
% explicitly:
cart.curr.corners = [q(1); 0] + cart.home.corners;

% cart.curr.upp_left.x    = cart.home.upp_left.x + q(1);
% cart.curr.upp_left.y    = cart.home.upp_left.y;
% 
% cart.curr.upp_right.x   = cart.home.upp_right.x + q(1);
% cart.curr.upp_right.y   = cart.home.upp_right.y;
% 
% cart.curr.low_right.x   = cart.home.low_right.x + q(1);
% cart.curr.low_right.y   = cart.home.low_right.y;
% 
% cart.curr.low_left.x    = cart.home.low_left.x + q(1);
% cart.curr.low_left.y    = cart.home.low_left.y;

%% Compute the 4 corners of the pendulum
% The pendulum is a rectangle whose center is q(1) = x_cart. The pendulum
% can translate horizontally and can rotate, so we first compute a 
% homogeneous transformation matrix T_pend in SE(2):

T_pend = [cos(q(2)), -sin(q(2)), q(1);
          sin(q(2)),  cos(q(2)), 0;
          0,          0,         1];

% We first compute the 4 corners of the pendulum when the robot is in the
% "home" configuration (q(1) = q(2) = 0):
pend.home.upp_left.x    = 0;
pend.home.upp_left.y    = 0.5*params.model.geom.pend.w;

pend.home.upp_right.x   = params.model.geom.pend.l;
pend.home.upp_right.y   = 0.5*params.model.geom.pend.w;

pend.home.low_right.x   = params.model.geom.pend.l;
pend.home.low_right.y   = -0.5*params.model.geom.pend.w;

pend.home.low_left.x    = 0;
pend.home.low_left.y    = -0.5*params.model.geom.pend.w;

pend.home.corners = horzcat([pend.home.upp_left.x; pend.home.upp_left.y;   1],...
                            [pend.home.upp_right.x; pend.home.upp_right.y; 1],...
                            [pend.home.low_right.x; pend.home.low_right.y; 1],...
                            [pend.home.low_left.x;  pend.home.low_left.y;  1]);

% Now compute the 4 corners of the pendulum after undergoing planar
% translation + rotation as described by T_pend:
pend.curr.corners = T_pend*pend.home.corners;

% pend.curr.upp_left.x    = pend.curr.corners(1,1);
% pend.curr.upp_left.y    = pend.curr.corners(2,1);
% 
% pend.curr.upp_right.x   = pend.curr.corners(1,2);
% pend.curr.upp_right.y   = pend.curr.corners(2,2);
% 
% pend.curr.low_right.x   = pend.curr.corners(1,3);
% pend.curr.low_right.y   = pend.curr.corners(2,3);
% 
% pend.curr.low_left.x    = pend.curr.corners(1,4);
% pend.curr.low_left.y    = pend.curr.corners(2,4);

%% Compute the (x,y) location of the pendulum's CoM
FK = fwd_kin(q,params);
pend.curr.com.x = FK(1,2);
pend.curr.com.y = FK(2,2);

%% Display the cart, pendulum, and the pendulum's CoM
fill(cart.curr.corners(1,:),cart.curr.corners(2,:),params.viz.colors.cart);
axis equal;
hold on;
fill(pend.curr.corners(1,:),pend.curr.corners(2,:),params.viz.colors.pend);
plot(pend.curr.com.x,pend.curr.com.y,'.','MarkerSize',50,...
    'MarkerFaceColor',params.viz.colors.pend_com);

end